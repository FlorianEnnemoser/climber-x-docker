!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
!
!  Module : s o i l _ t e m p _ m o d
!
!  Purpose : soil temperature
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
! Copyright (C) 2017-2022 Potsdam Institute for Climate Impact Research,
!                         Matteo Willeit and Andrey Ganopolski
!
! This file is part of CLIMBER-X.
!
! CLIMBER-X is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
! CLIMBER-X is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
! You should have received a copy of the GNU General Public License
! along with CLIMBER-X.  If not, see <http://www.gnu.org/licenses/>.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
module soil_temp_mod

  use precision, only : wp
  use constants, only : rho_w, rho_i, Lf, g, T0, cap_i
  use timer, only : time_soy_lnd
  use control, only : check_energy, check_water
  use lnd_grid, only : z, dz, nl, rdz_pos, rdz_neg, ic_min, ic_peat, ncarb
  use lnd_params, only : dt, rdt, soilc_par 
  use tridiag, only : tridiag_solve

  implicit none

  private
  public :: soil_temp

contains

  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !   Subroutine :  s o i l _ t e m p
  !   Purpose    :  compute soil temperature and phase changes 
  !              :  by solving the tridiagonal system
  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine soil_temp(mask_snow,h_snow,cap_soil,lambda_int, &
                      psi_sat,psi_exp,theta_sat,soil_resp_l,f_peat,flx_g,dflxg_dT,flx_melt, &
                      t_soil,t_soil_cum,w_snow,w_w,w_i,theta_w,theta_i,snowmelt, &
                      t_soil_old,w_snow_old,w_w_old,w_i_old,w_w_phase,w_i_phase, &
                      energy_cons_soil,i,j)

    implicit none

    integer, intent(in) :: mask_snow
    real(wp), intent(in) :: h_snow
    real(wp), intent(in) :: flx_g, dflxg_dT, flx_melt
    real(wp), dimension(0:), intent(in) :: cap_soil, lambda_int
    real(wp), dimension(:), intent(in) :: psi_sat, theta_sat
    integer, dimension(:), intent(in) :: psi_exp
    real(wp), dimension(:,:), intent(in) :: soil_resp_l
    real(wp), intent(in) :: f_peat
    real(wp), intent(inout) :: w_snow
    real(wp), dimension(:), intent(inout) :: w_w, w_i, theta_w, theta_i
    real(wp), dimension(0:), intent(inout) :: t_soil
    real(wp), dimension(:), intent(inout) :: t_soil_cum
!    real(wp), intent(out) :: snowmelt, w_snow_old
    real(wp), intent(out) :: snowmelt
    real(wp), intent(inout) :: w_snow_old
    real(wp), dimension(:), intent(out) :: w_w_old, w_i_old, w_w_phase, w_i_phase
    real(wp), dimension(0:), intent(out) :: t_soil_old
    real(wp), intent(out) :: energy_cons_soil

    integer :: i, j, k
    real(wp), dimension(0:nl) :: a, b, c, r, x
    real(wp), dimension(0:nl) :: cap, rcap
    real(wp), dimension(0:nl) :: dz_loc, z_loc, rdz_loc_pos, rdz_loc_neg
    real(wp), dimension(nl) :: heat_decomp
    real(wp) :: w_melt, w_ice, w_liq, w_liq_max, H, H_star, w_snow_tmp, dw_snow, energy_warm_snow, flx_excess
    real(wp) :: i_p, j_p, n_p, sum_water
    logical :: melt, i_print

    i_print = .false.
    n_p = 1
    i_p = 65
    j_p = 31
    i_print = i_print .and. i.eq.i_p .and. j.eq.j_p

    ! set snowmelt to zero
    snowmelt = 0._wp
    energy_warm_snow = 0._wp

    dz_loc(0) = h_snow
    z_loc(0) = -0.5_wp * dz_loc(0)
    dz_loc(1:nl) = dz(1:nl)
    z_loc(1:nl) = z(1:nl)

    rdz_loc_pos(1:nl-1) = rdz_pos(1:nl-1)
    rdz_loc_neg(2:nl) = rdz_neg(2:nl)
    rdz_loc_pos(0) = 1._wp / (z_loc(1) - z_loc(0))
    rdz_loc_neg(1) = 1._wp / (z_loc(1) - z_loc(0))

    ! assign some arrays
    cap = cap_soil*dz_loc  ! J/m2/K
    rcap(1:nl) = 1._wp/cap(1:nl)
    if( cap(0).gt.0._wp ) rcap(0) = 1._wp/cap(0)

    ! save old prognostic variables
    t_soil_old = t_soil
    w_w_old = w_w
    w_i_old = w_i
    w_snow_old = w_snow

    ! heat generated by soil carbon decomposition (Khvorostyanov 2008)
    if( soilc_par%heat_soc ) then
      heat_decomp = ((1._wp-f_peat) * soil_resp_l(:,ic_min) + f_peat * soil_resp_l(:,ic_peat)) * soilc_par%heat_decomp_spec  ! kgC/m3/s * J/kgC = W/m3
    else
      heat_decomp = 0._wp
    endif


    if( mask_snow .eq. 1 ) then 

      ! top layer, snow, k=0
      k = 0
      a(k) = 0._wp
      b(k) = 1._wp + dt * rcap(k) * ( lambda_int(k) * rdz_loc_pos(k) - dflxg_dT )
      c(k) = - dt * rcap(k) * lambda_int(k) * rdz_loc_pos(k)
      r(k) = t_soil(k) + dt * rcap(k) * ( flx_g - dflxg_dT*t_soil(k) )

      ! intermediate layers
      do k=1,nl-1
        a(k) = - dt * rcap(k) * lambda_int(k-1) * rdz_loc_neg(k)
        b(k) = 1._wp + dt * rcap(k) * ( lambda_int(k-1) * rdz_loc_neg(k) + lambda_int(k) * rdz_loc_pos(k) )
        c(k) = - dt * rcap(k) * lambda_int(k) * rdz_loc_pos(k)
        r(k) = t_soil(k) + dt * rcap(k) * dz_loc(k) * heat_decomp(k)
      enddo

      ! bottom layer, k=nl
      k = nl
      a(k) = - dt * rcap(k) * lambda_int(k-1) * rdz_loc_neg(k)
      b(k) = 1._wp + dt * rcap(k) * lambda_int(k-1) * rdz_loc_neg(k)
      c(k) = 0._wp
      r(k) = t_soil(k) + dt * rcap(k) * dz_loc(k) * heat_decomp(k)

      ! solve tridiagonal system
      call tridiag_solve(a,b,c,r,x,nl+1)
      ! assign new soil temperature
      t_soil = x


      ! PHASE CHANGE

      do k=0,nl
        if( k .eq. 0 ) then 
          w_ice = w_snow
          w_liq = 0._wp
          w_liq_max = -1._wp
        else
          w_ice = w_i(k)
          w_liq = w_w(k)
          ! maximum liquid water content, kg/m2, Niu 2006 (WRONG in CLM technical report)
          if( t_soil(k) .lt. T0 ) then
            w_liq_max = dz_loc(k) * rho_w * theta_sat(k) &
            * ( Lf / (g*t_soil(k)*psi_sat(k)) * (t_soil(k)-T0) )**(1._wp/psi_exp(k))
          else
            w_liq_max = dz_loc(k) * rho_w * theta_sat(k)
          endif
        endif


        ! freezing or melting occuring
        if( (t_soil(k).gt.T0 .and. w_ice.gt.0._wp) .or. (k.ne.0 .and. t_soil(k).lt.T0 .and. w_liq.gt.w_liq_max) ) then
          if( (t_soil(k).gt.T0 .and. w_ice.gt.0._wp) ) then
            melt = .true.
          else
            melt = .false.
          endif

          if( k .eq. 0 ) then ! snow layer
            H = (dflxg_dT -cap(k)*rdt) * (T0 - t_soil(k)) ! W/m2
          else ! soil layers
            H = -cap(k)*rdt*(T0 - t_soil(k))
          endif

          w_melt = H*dt/Lf  ! kg/m2

          ! melting
          if( w_melt .gt. 0._wp .and. melt ) then
            if( k .eq. 0 ) then
              t_soil(k) = T0
              if (w_melt.le.w_ice) then
                snowmelt = w_melt*rdt  ! kg/m2/s
                w_snow = w_ice-w_melt
              else ! not enough snow to melt
                snowmelt = w_ice*rdt  ! kg/m2/s
                w_snow = 0._wp
                H_star = Lf*(w_melt-w_ice)*rdt
                ! add excess energy to first soil layer
                t_soil(1) = t_soil(1) + dt*rcap(1)*H_star
                ! distribute the excess energy to all soil layers
                !t_soil(1:nl) = t_soil(1:nl) + dt*rcap(1:nl)*H_star * dz_loc(1:nl)/sum(dz_loc(1:nl))
              endif
            else
              if (w_melt.le.w_ice) then
                w_i(k) = w_ice-w_melt
                t_soil(k) = T0
              else ! not enough ice to melt
                w_i(k) = 0._wp
                H_star = Lf*(w_melt-w_ice)*rdt
                t_soil(k) = T0 + dt*rcap(k)*H_star
              endif
            endif

          ! freezing
          else if( w_melt.lt.0._wp .and. (.not.melt) ) then

            if( w_liq+w_ice .ge. w_liq_max ) then
              w_i(k) = min(w_liq+w_ice-w_liq_max, w_ice-w_melt) 
            else
              w_i(k) = 0._wp
            endif

            ! determine energy not used/released during melt/freezing processes and adjust temperature if necessary
            H_star = H - Lf * (w_ice-w_i(k)) * rdt
            t_soil(k) = T0 + dt*rcap(k) * H_star

          endif

          ! update liquid water content
          if( k .ne. 0 ) w_w(k) = w_liq+w_ice - w_i(k)

        endif

        ! use flx_melt to directly melt part of the snow layer 
        ! without the need for the whole snow layer to reach melting point
        if (k.eq.0 .and. flx_melt.gt.0._wp) then
          dw_snow = flx_melt / (rdt*((T0-t_soil(0))*cap_i+Lf))
          if (dw_snow.le.w_snow) then
            ! enough snow to melt
            snowmelt = snowmelt + dw_snow*rdt  ! kg/m2/s
            w_snow = w_snow-dw_snow
            energy_warm_snow = rdt*(T0-t_soil(0))*cap_i*dw_snow ! W/m2
          else
            ! not enough snow to melt
            ! melt all
            snowmelt = snowmelt + w_snow*rdt  ! kg/m2/s
            ! determine energy not used during melt and adjust temperature
            flx_excess = flx_melt + dflxg_dT*(T0-t_soil(0)) - w_snow*rdt*Lf - rdt*(T0-t_soil(0))*cap_i*w_snow  ! W/m2
            w_snow = 0._wp
            t_soil(0) = T0
            ! add excess energy to first soil layer
            t_soil(1) = t_soil(1) + dt*rcap(1) * flx_excess
            ! distribute the excess energy to all soil layers
            !t_soil(1:nl) = t_soil(1:nl) + dt*rcap(1:nl) * flx_excess * dz_loc(1:nl) / sum(dz_loc(1:nl))
          endif
        endif

      enddo


    else ! w_snow lower than w_snow_crit, no explicit snow layer

      ! top layer, k=1
      k = 1
      a(k) = 0._wp
      b(k) = 1._wp + dt * rcap(k) * ( lambda_int(k) * rdz_loc_pos(k) - dflxg_dT )
      c(k) = - dt * rcap(k) * lambda_int(k) * rdz_loc_pos(k)
      r(k) = t_soil(k) + dt * rcap(k) * ( flx_g - dflxg_dT*t_soil(k) ) + dt * rcap(k) * dz_loc(k) * heat_decomp(k)

      ! intermediate layers
      do k=2,nl-1
        a(k) = - dt * rcap(k) * lambda_int(k-1) * rdz_loc_neg(k)
        b(k) = 1._wp + dt * rcap(k) * ( lambda_int(k-1) * rdz_loc_neg(k) + lambda_int(k) * rdz_loc_pos(k) )
        c(k) = - dt * rcap(k) * lambda_int(k) * rdz_loc_pos(k)
        r(k) = t_soil(k) + dt * rcap(k) * dz_loc(k) * heat_decomp(k)
      enddo

      ! bottom layer, k=nl
      k = nl
      a(k) = - dt * rcap(k) * lambda_int(k-1) * rdz_loc_neg(k)
      b(k) = 1._wp + dt * rcap(k) * lambda_int(k-1) * rdz_loc_neg(k)
      c(k) = 0._wp
      r(k) = t_soil(k) + dt * rcap(k) * dz_loc(k) * heat_decomp(k)

      ! solve tridiagonal system
      call tridiag_solve(a(1:nl),b(1:nl),c(1:nl),r(1:nl),x(1:nl),nl)
      ! assign new soil temperature
      t_soil(1:nl) = x(1:nl)


      ! PHASE CHANGE

      do k=1,nl
        w_ice = w_i(k)
        w_liq = w_w(k)
        ! maximum liquid water content, kg/m2, Niu 2006 (WRONG in CLM technical report)
        if( t_soil(k) .lt. T0 ) then
          w_liq_max = dz_loc(k) * rho_w * theta_sat(k) & 
          * ( Lf / (g*t_soil(k)*psi_sat(k)) * (t_soil(k)-T0) )**(1._wp/psi_exp(k))
        else
          w_liq_max = dz_loc(k) * rho_w * theta_sat(k)
        endif

        ! freezing or melting occuring
        if( (t_soil(k).gt.T0 .and. w_ice.gt.0._wp) .or. (t_soil(k).lt.T0 .and. w_liq.gt.w_liq_max) ) then
          if( (t_soil(k).gt.T0 .and. w_ice.gt.0._wp) ) then
            melt = .true.
          else
            melt = .false.
          endif

          if( k .eq. 1 ) then
            H = dflxg_dT * (T0 - t_soil(k)) - cap(k)*rdt*(T0 -t_soil(k))  ! W/m2
          else
            ! intermediate soil layers
            H = -cap(k)*rdt*(T0 - t_soil(k))
          endif

          ! update ice content
          w_melt = H*dt/Lf  ! kg/m2

          ! melting
          if( w_melt .gt. 0._wp .and. melt ) then

            ! instead of melting ice in the first soil layer, first use it to melt 'invisible' snow
            if( k.eq.1 ) then
              w_snow = max(0._wp, w_snow-w_melt)
              snowmelt = (w_snow_old - w_snow) * rdt  ! kg/m2/s
              H = H - Lf * snowmelt  ! W/m2
              w_melt = H*dt/Lf  ! kg/m2
            endif

            w_i(k) = max(0._wp, w_ice-w_melt)
            ! determine energy not used during melt and adjust temperature if necessary
            if( k .eq. 1 ) then
              H_star = H - Lf * (w_ice - w_i(k)) * rdt
              t_soil(k) = T0 + dt*rcap(k) * H_star / (1._wp - dt*rcap(k)*dflxg_dT)
            else
              H_star = H - Lf * (w_ice - w_i(k)) * rdt
              t_soil(k) = T0 + dt*rcap(k) * H_star
            endif

          ! freezing
          else if( w_melt .lt. 0._wp .and. (.not. melt) ) then
            if( (w_liq+w_ice) .ge. w_liq_max ) then
              w_i(k) = min(w_liq+w_ice-w_liq_max, w_ice-w_melt) 
            else
              w_i(k) = 0._wp
            endif
            ! determine energy not released during freezing and adjust temperature if necessary
            if( k .eq. 1 ) then
              H_star = H - Lf * (w_ice - w_i(k)) * rdt
              t_soil(k) = T0 + dt*rcap(k) * H_star / (1._wp - dt*rcap(k)*dflxg_dT)
            else
              H_star = H - Lf * (w_ice - w_i(k)) * rdt
              t_soil(k) = T0 + dt*rcap(k) * H_star
            endif

          endif

          ! update liquid water content
          w_w(k) = w_liq+w_ice - w_i(k)

        endif

      enddo

      ! use flx_melt to directly melt (not-explicit) snow (if present)
      if (flx_melt.gt.0._wp) then
        dw_snow = flx_melt / (rdt*Lf) ! snow that can be melted
        if (dw_snow.le.w_snow) then
          ! enough snow to melt
          snowmelt = snowmelt + dw_snow*rdt  ! kg/m2/s
          w_snow = w_snow-dw_snow
        else
          ! not enough snow to melt
          ! melt all
          snowmelt = snowmelt + w_snow*rdt  ! kg/m2/s
          ! determine energy not used during melt
          flx_excess = flx_melt - w_snow*rdt*Lf ! W/m2
          w_snow = 0._wp
          ! use flx_excess to warm top soil layer
          t_soil(1) = (t_soil(1) + dt*rcap(1) * (flx_excess-dflxg_dT*t_soil(1))) / (1._wp-dflxg_dT*dt*rcap(1))
        endif
      endif

      ! if snow present but no explicit snow layer, use possible first soil layer excess energy to melt snow
      if( w_snow.gt.0._wp ) then
        H = dflxg_dT * (T0 - t_soil(1)) - cap(1)*rdt*(T0 - t_soil(1))

        if( H .gt. 0._wp ) then

          w_melt = H*dt/Lf ! kg/m2
          w_snow_tmp = w_snow
          w_snow = max( 0._wp, w_snow-w_melt )  ! kg/m2
          H_star = H - Lf*rdt * (w_snow_tmp - w_snow)

          w_ice = w_i(1)
          w_i(1) = max(0._wp, w_ice-w_melt)
          w_w(1) = w_w(1)+w_ice - w_i(1)

          t_soil(1) = T0 + dt*rcap(1) * H_star / (1._wp - dt*rcap(1) * dflxg_dT)

          snowmelt = snowmelt + (w_snow_tmp - w_snow) * rdt  ! kg/m2/s

        endif
      endif

      ! set temperature of non existing snow layer equal to first ice layer
      t_soil(0) = min(T0, t_soil(1))

    endif

    ! update unfrozen fraction of soil water based on new soil temperature profile

    ! update theta
    do k=1,nl

      theta_w(k) = w_w(k) / (dz_loc(k) * rho_w)
      theta_i(k) = w_i(k) / (dz_loc(k) * rho_i)

      w_w_phase(k) = w_w(k)
      w_i_phase(k) = w_i(k)

    enddo


    if( check_energy ) then
      ! soil energy balance
      if( mask_snow .eq. 1 ) then
        energy_cons_soil = flx_g + dflxg_dT*(t_soil(0)-t_soil_old(0)) + flx_melt + sum(heat_decomp*dz_loc(1:nl)) &
        - sum(Lf*rdt * (w_i_old-w_i)) &
        - Lf*snowmelt - energy_warm_snow &
        - sum(cap*rdt * (t_soil-t_soil_old))
      else
        energy_cons_soil =  flx_g + dflxg_dT*(t_soil(1)-t_soil_old(1)) + flx_melt + sum(heat_decomp*dz_loc(1:nl)) &
        - sum(Lf*rdt * (w_i_old-w_i)) &
        - Lf*snowmelt &
        - sum(cap(1:nl)*rdt * (t_soil(1:nl)-t_soil_old(1:nl)))
      endif


      if(abs(energy_cons_soil).gt.1.d-10 ) then
        print *,' '
        print *,'energy conservation ',energy_cons_soil
        print *,'i,j,mask_snow',i,j,mask_snow
        print *,'t_soil_old',t_soil_old
        print *,'t_soil_after_cond',x
        print *,'t_soil_new',t_soil
        print *,'w_i_old',w_i_old
        print *,'w_i_new',w_i
        print *,'heat_soc',sum(heat_decomp*dz_loc(1:nl))
        if(mask_snow.eq.1) then
          print *,'g,dg_dT',flx_g,dflxg_dT*(t_soil(0)-t_soil_old(0)),flx_g+dflxg_dT*(t_soil(0)-t_soil_old(0))
          print *,'dsnow dT',energy_warm_snow
          print *,'flx_melt',flx_melt
        else
          print *,'g,dg_dT',flx_g,dflxg_dT*(t_soil(1)-t_soil_old(1)),flx_g+dflxg_dT*(t_soil(1)-t_soil_old(1))
        endif
        print *,'energy_internal',cap*rdt * (t_soil-t_soil_old)
        print *,'phase change',Lf*rdt * (w_i_old-w_i)
        print *,'snowmelt energy',Lf*snowmelt
        print *,'snow_new,snow_old,snowmelt',w_snow,w_snow_old,snowmelt*dt
        print *,'cap',cap
        print *,'lambda_int',lambda_int
        print *,' '
        !       if(abs(energy_cons_soil).gt.10.) stop
      endif
    endif

    if( check_water ) then
      ! soil water balance
      sum_water = sum(w_w - w_w_old + w_i - w_i_old)
      if( abs(sum_water+w_snow - w_snow_old+snowmelt*dt) .gt. 1.d-10 ) then
        print *,'water conservation ',sum_water+snowmelt*dt+w_snow - w_snow_old 
        print *,w_snow,w_snow_old,snowmelt
        print *,w_w(k),w_w_old(k)
        print *,w_i(k),w_i_old(k)
        stop
      endif
    endif


    ! check temperature range
    if(maxval(t_soil) .gt. 350._wp .or. minval(t_soil) .lt. 150._wp) then
      print *,''
      print *,'WARNING t_soil out of range',t_soil
      print *,'i,j',i,j
      print *,'masksnow',mask_snow
      k = 0
      print *,'SNOW layer'
      print *,'mask_snow,snowmelt',mask_snow, snowmelt*dt
      print *,'t_snow, before, after',t_soil_old(k),t_soil(k)
      print *,'w_snow, before, after',w_snow_old,w_snow

      k=1
      print *,'top soil layer'
      print *,'t_soil, before, after',t_soil_old(k),t_soil(k)
      print *,'w_w, before, after',w_w_old(k),w_w(k)
      print *,'w_i, before, after',w_i_old(k),w_i(k)
      print *,'g,dg_dT*dT',flx_g,dflxg_dT,dflxg_dT*(t_soil(1)-t_soil_old(1))
      print *,'flx_melt',flx_melt
      print *,'cap,lambda',cap, lambda_int
      print *,''
      !if(i.eq.54.and.j.eq.25) stop
    endif

    if(i_print .and. i.eq.54.and.j.eq.25) then
      print *,''
      print *,'WARNING t_soil out of range',t_soil
      print *,'i,j',i,j
      print *,'masksnow',mask_snow
      k = 0
      print *,'SNOW layer'
      print *,'mask_snow,snowmelt',mask_snow, snowmelt*dt
      print *,'t_snow, before, after',t_soil_old(k),t_soil(k)
      print *,'w_snow, before, after',w_snow_old,w_snow

      k=1
      print *,'top soil layer'
      print *,'t_soil, before, after',t_soil_old(k),t_soil(k)
      print *,'w_w, before, after',w_w_old(k),w_w(k)
      print *,'w_i, before, after',w_i_old(k),w_i(k)
      print *,'g,dg_dT',flx_g,dflxg_dT*(t_soil(1)-t_soil_old(1))
      print *,'cap,lambda',cap, lambda_int
      print *,''
    endif


    ! cumulate for soil carbon decomposition
    if (time_soy_lnd) t_soil_cum = 0._wp
    t_soil_cum = t_soil_cum + t_soil(1:nl)

    return

  end subroutine soil_temp

end module soil_temp_mod

