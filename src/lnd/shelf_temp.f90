!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
!
!  Module : s h e l f _ t e m p _ m o d
!
!  Purpose : shelf temperature
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
! Copyright (C) 2017-2022 Potsdam Institute for Climate Impact Research,
!                         Matteo Willeit and Andrey Ganopolski
!
! This file is part of CLIMBER-X.
!
! CLIMBER-X is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
! CLIMBER-X is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
! You should have received a copy of the GNU General Public License
! along with CLIMBER-X.  If not, see <http://www.gnu.org/licenses/>.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
module shelf_temp_mod

  use precision, only : wp
  use constants, only : rho_w, rho_i, Lf, g, T0
  use timer, only : time_soy_lnd
  use control, only : check_energy, check_water
  use lnd_grid, only : z, dz, nl, rdz_pos, rdz_neg, ic_shelf, ncarb
  use lnd_params, only : dt, rdt, soilc_par 
  use tridiag, only : tridiag_solve

  implicit none

  private
  public :: shelf_temp

contains

  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !   Subroutine :  s h e l f _ t e m p
  !   Purpose    :  compute shelf soil temperature and phase changes 
  !              :  by solving the tridiagonal system
  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine shelf_temp(cap_shelf,lambda_int_shelf,psi_sat,psi_exp,theta_sat,soil_resp_l, &
                      t_shelf,w_w_shelf,w_i_shelf,theta_w_shelf,theta_i_shelf, &
                      t_shelf_cum,theta_w_shelf_cum,theta_i_shelf_cum, &
                      energy_cois_shelf,i,j)

    implicit none

    real(wp), dimension(:), intent(in) :: cap_shelf
    real(wp), dimension(0:), intent(in) :: lambda_int_shelf
    real(wp), dimension(:), intent(in) :: psi_sat, theta_sat
    integer, dimension(:), intent(in) :: psi_exp
    real(wp), dimension(:,:), intent(in) :: soil_resp_l
    real(wp), dimension(:), intent(inout) :: w_w_shelf, w_i_shelf, theta_w_shelf, theta_i_shelf
    real(wp), dimension(0:), intent(inout) :: t_shelf
    real(wp), dimension(:), intent(inout) :: t_shelf_cum, theta_w_shelf_cum, theta_i_shelf_cum
    real(wp), intent(out) :: energy_cois_shelf

    integer :: i,j
    integer :: k
    real(wp), dimension(0:nl) :: t_shelf_old
    real(wp), dimension(nl) :: w_w_old, w_i_old
    real(wp), dimension(nl) :: a, b, c, r, x
    real(wp), dimension(nl) :: cap, rcap
    real(wp), dimension(nl) :: heat_decomp
    real(wp) :: w_melt, w_ice, w_liq, w_liq_max, H, H_star
    real(wp) :: i_p, j_p, n_p
    logical :: melt, i_print

    i_print = .false.
    n_p = 1
    i_p = 65
    j_p = 31
    i_print = i_print .and. i.eq.i_p .and. j.eq.j_p


    ! assign some arrays
    cap = cap_shelf*dz(1:nl)  ! J/m2/K
    rcap = 1._wp/cap
    rdz_neg(1) = 1._wp / (z(1) - 0._wp)

    ! save old prognostic variables
    t_shelf_old = t_shelf
    w_w_old = w_w_shelf
    w_i_old = w_i_shelf

    ! heat generated by soil carbon decomposition (Khvorostyanov 2008)
    if( soilc_par%heat_soc ) then
      heat_decomp = soil_resp_l(:,ic_shelf) * soilc_par%heat_decomp_spec  ! kgC/m3/s * J/kgC = W/m3
    else
      heat_decomp = 0._wp
    endif

    ! top layer, k=1
    k = 1
    a(k) = 0._wp
    b(k) = 1._wp + dt * rcap(k) * (lambda_int_shelf(k) * rdz_pos(k) + lambda_int_shelf(k-1) * rdz_neg(k))
    c(k) = - dt * rcap(k) * lambda_int_shelf(k) * rdz_pos(k)
    r(k) = t_shelf(k) + dt*rcap(k)*lambda_int_shelf(k-1)*rdz_neg(k)*t_shelf(0) + dt*rcap(k)*dz(k)*heat_decomp(k)

    ! intermediate layers
    do k=2,nl-1
      a(k) = - dt * rcap(k) * lambda_int_shelf(k-1) * rdz_neg(k)
      b(k) = 1._wp + dt * rcap(k) * ( lambda_int_shelf(k-1) * rdz_neg(k) + lambda_int_shelf(k) * rdz_pos(k) )
      c(k) = - dt * rcap(k) * lambda_int_shelf(k) * rdz_pos(k)
      r(k) = t_shelf(k) + dt * rcap(k) * dz(k) * heat_decomp(k)
    enddo

    ! bottom layer, k=nl
    k = nl
    a(k) = - dt * rcap(k) * lambda_int_shelf(k-1) * rdz_neg(k)
    b(k) = 1._wp + dt * rcap(k) * lambda_int_shelf(k-1) * rdz_neg(k)
    c(k) = 0._wp
    r(k) = t_shelf(k) + dt * rcap(k) * dz(k) * heat_decomp(k)

    ! solve tridiagonal system
    call tridiag_solve(a,b,c,r,x,nl)
    ! assign new shelf temperature
    t_shelf(1:nl) = x


    ! PHASE CHANGE

    do k=1,nl
      w_ice = w_i_shelf(k)
      w_liq = w_w_shelf(k)
      ! maximum liquid water content, kg/m2, Niu 2006 (WRONG in CLM technical report)
      if( t_shelf(k) .lt. T0 ) then
        w_liq_max = dz(k) * rho_w * theta_sat(k) & 
        * ( Lf / (g*t_shelf(k)*psi_sat(k)) * (t_shelf(k)-T0) )**(1._wp/psi_exp(k))
      else
        w_liq_max = dz(k) * rho_w * theta_sat(k)
      endif

      ! freezing or melting occuring
      if( (t_shelf(k).gt.T0 .and. w_ice.gt.0._wp) .or. (t_shelf(k).lt.T0 .and. w_liq.gt.w_liq_max) ) then
        if( (t_shelf(k).gt.T0 .and. w_ice.gt.0._wp) ) then
          melt = .true.
        else
          melt = .false.
        endif

        H = -cap(k)*rdt*(T0 - t_shelf(k))
        ! update ice content
        w_melt = H*dt/Lf  ! kg/m2

        ! melting
        if( w_melt .gt. 0._wp .and. melt ) then
          w_i_shelf(k) = max(0._wp, w_ice-w_melt)
          ! determine energy not used during melt and adjust temperature if necessary
          H_star = H - Lf * (w_ice - w_i_shelf(k)) * rdt
          t_shelf(k) = T0 + dt*rcap(k) * H_star

        ! freezing
        else if( w_melt .lt. 0._wp .and. (.not. melt) ) then
          if( (w_liq+w_ice) .ge. w_liq_max ) then
            w_i_shelf(k) = min(w_liq+w_ice-w_liq_max, w_ice-w_melt) 
          else
            w_i_shelf(k) = 0._wp
          endif
          ! determine energy not released during freezing and adjust temperature if necessary
          H_star = H - Lf * (w_ice - w_i_shelf(k)) * rdt
          t_shelf(k) = T0 + dt*rcap(k) * H_star

        endif

        ! update liquid water content
        w_w_shelf(k) = w_liq+w_ice - w_i_shelf(k)

      endif

    enddo


    ! update theta
    do k=1,nl
      theta_w_shelf(k) = w_w_shelf(k) / (dz(k) * rho_w)
      theta_i_shelf(k) = w_i_shelf(k) / (dz(k) * rho_i)
    enddo

    if( check_energy ) then
      ! shelf energy balance
      energy_cois_shelf = -lambda_int_shelf(0)*rdz_neg(1)*(x(1)-t_shelf(0)) &
      + sum(heat_decomp*dz(1:nl)) &
      - sum(Lf*rdt * (w_i_old-w_i_shelf)) &
      - sum(cap*rdt * (t_shelf(1:nl)-t_shelf_old(1:nl)))

      if(abs(energy_cois_shelf).gt.1.d-10 ) then
        print *,' '
        print *,'energy conservation SHELF',energy_cois_shelf
        print *,'i,j',i,j
        print *,'t_shelf_old',t_shelf_old
        print *,'t_shelf_after_cond',x
        print *,'t_shelf_new',t_shelf
        print *,'w_i_old',w_i_old
        print *,'w_i_new',w_i_shelf
        print *,'flux_in',-lambda_int_shelf(0)*rdz_neg(1)*(t_shelf(1)-t_shelf(0))
        print *,'heat_soc',sum(heat_decomp*dz(1:nl))
        print *,'energy_internal',cap*rdt * (t_shelf(1:nl)-t_shelf_old(1:nl))
        print *,'phase change',Lf*rdt * (w_i_old-w_i_shelf)
        print *,'cap',cap
        print *,'lambda_int_shelf',lambda_int_shelf
        print *,' '
        !       if(abs(energy_cois_shelf).gt.10.) stop
      endif
    endif


    ! check temperature range
    if(maxval(t_shelf) .gt. 350._wp .or. minval(t_shelf) .lt. 200._wp) then
      print *,''
      print *,'WARNING t_shelf out of range',t_shelf
      print *,'i,j',i,j
      k=1
      print *,'top shelf layer'
      print *,'t_shelf, before, after',t_shelf_old(k),t_shelf(k)
      print *,'w_w, before, after',w_w_old(k),w_w_shelf(k)
      print *,'w_i, before, after',w_i_old(k),w_i_shelf(k)
      print *,'cap,lambda',cap, lambda_int_shelf
      print *,''
      !if(i.eq.54.and.j.eq.25) stop
    endif

    if(i_print .and. i.eq.54.and.j.eq.25) then
      print *,''
      print *,'WARNING t_shelf out of range',t_shelf
      print *,'i,j',i,j

      k=1
      print *,'top shelf layer'
      print *,'t_shelf, before, after',t_shelf_old(k),t_shelf(k)
      print *,'w_w, before, after',w_w_old(k),w_w_shelf(k)
      print *,'w_i, before, after',w_i_old(k),w_i_shelf(k)
      print *,'cap,lambda',cap, lambda_int_shelf
      print *,''
    endif


    ! cumulate for shelf carbon decomposition
    if (time_soy_lnd) then
      t_shelf_cum = 0._wp
      theta_w_shelf_cum = 0._wp
      theta_i_shelf_cum = 0._wp
    endif
    t_shelf_cum = t_shelf_cum + t_shelf(1:nl)
    theta_w_shelf_cum = theta_w_shelf_cum + theta_w_shelf
    theta_i_shelf_cum = theta_i_shelf_cum + theta_i_shelf


    return

  end subroutine shelf_temp

end module shelf_temp_mod

