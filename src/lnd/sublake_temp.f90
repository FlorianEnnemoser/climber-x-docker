!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
!
!  Module : s u b l a k e _ t e m p _ m o d
!
!  Purpose : temperature of soil below lake
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
! Copyright (C) 2017-2022 Potsdam Institute for Climate Impact Research,
!                         Matteo Willeit and Andrey Ganopolski
!
! This file is part of CLIMBER-X.
!
! CLIMBER-X is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
! CLIMBER-X is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
! You should have received a copy of the GNU General Public License
! along with CLIMBER-X.  If not, see <http://www.gnu.org/licenses/>.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
module sublake_temp_mod

  use precision, only : wp
  use constants, only : rho_w, rho_i, Lf, g, T0
  use timer, only : time_soy_lnd
  use control, only : check_energy, check_water
  use lnd_grid, only : z, dz, nl, rdz_pos, rdz_neg, ic_lake, ncarb
  use lnd_params, only : dt, rdt, soilc_par 
  use tridiag, only : tridiag_solve

  implicit none

  private
  public :: sublake_temp

contains

  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !   Subroutine :  s u b l a k e _ t e m p
  !   Purpose    :  compute soil temperature and phase changes below lake
  !              :  by solving the tridiagonal system
  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine sublake_temp(cap_sublake,lambda_int_sublake,psi_sat,psi_exp,theta_sat,soil_resp_l, &
                      t_sublake,w_w_sublake,w_i_sublake,theta_w_sublake,theta_i_sublake, &
                      t_sublake_cum,theta_w_sublake_cum,theta_i_sublake_cum, &
                      energy_cois_lake,i,j)

    implicit none

    real(wp), dimension(:), intent(in) :: cap_sublake
    real(wp), dimension(0:), intent(in) :: lambda_int_sublake
    real(wp), dimension(:), intent(in) :: psi_sat, theta_sat
    integer, dimension(:), intent(in) :: psi_exp
    real(wp), dimension(:,:), intent(in) :: soil_resp_l
    real(wp), dimension(:), intent(inout) :: w_w_sublake, w_i_sublake, theta_w_sublake, theta_i_sublake
    real(wp), dimension(0:), intent(inout) :: t_sublake
    real(wp), dimension(:), intent(inout) :: t_sublake_cum, theta_w_sublake_cum, theta_i_sublake_cum
    real(wp), intent(out) :: energy_cois_lake

    integer :: i,j
    integer :: k
    real(wp), dimension(0:nl) :: t_sublake_old
    real(wp), dimension(nl) :: w_w_old, w_i_old
    real(wp), dimension(nl) :: a, b, c, r, x
    real(wp), dimension(nl) :: cap, rcap
    real(wp), dimension(nl) :: heat_decomp
    real(wp) :: w_melt, w_ice, w_liq, w_liq_max, H, H_star
    real(wp) :: i_p, j_p, n_p
    logical :: melt, i_print

    i_print = .false.
    n_p = 1
    i_p = 65
    j_p = 31
    i_print = i_print .and. i.eq.i_p .and. j.eq.j_p


    ! assign some arrays
    cap = cap_sublake*dz(1:nl)  ! J/m2/K
    rcap = 1._wp/cap
    rdz_neg(1) = 1._wp / (z(1) - 0._wp)

    ! save old prognostic variables
    t_sublake_old = t_sublake
    w_w_old = w_w_sublake
    w_i_old = w_i_sublake

    ! heat generated by soil carbon decomposition (Khvorostyanov 2008)
    if( soilc_par%heat_soc ) then
      heat_decomp = soil_resp_l(:,ic_lake) * soilc_par%heat_decomp_spec  ! kgC/m3/s * J/kgC = W/m3
    else
      heat_decomp = 0._wp
    endif

    ! top layer, k=1
    k = 1
    a(k) = 0._wp
    b(k) = 1._wp + dt * rcap(k) * (lambda_int_sublake(k) * rdz_pos(k) + lambda_int_sublake(k-1) * rdz_neg(k))
    c(k) = - dt * rcap(k) * lambda_int_sublake(k) * rdz_pos(k)
    r(k) = t_sublake(k) + dt*rcap(k)*lambda_int_sublake(k-1)*rdz_neg(k)*t_sublake(0) + dt*rcap(k)*dz(k)*heat_decomp(k)

    ! intermediate layers
    do k=2,nl-1
      a(k) = - dt * rcap(k) * lambda_int_sublake(k-1) * rdz_neg(k)
      b(k) = 1._wp + dt * rcap(k) * ( lambda_int_sublake(k-1) * rdz_neg(k) + lambda_int_sublake(k) * rdz_pos(k) )
      c(k) = - dt * rcap(k) * lambda_int_sublake(k) * rdz_pos(k)
      r(k) = t_sublake(k) + dt * rcap(k) * dz(k) * heat_decomp(k)
    enddo

    ! bottom layer, k=nl
    k = nl
    a(k) = - dt * rcap(k) * lambda_int_sublake(k-1) * rdz_neg(k)
    b(k) = 1._wp + dt * rcap(k) * lambda_int_sublake(k-1) * rdz_neg(k)
    c(k) = 0._wp
    r(k) = t_sublake(k) + dt * rcap(k) * dz(k) * heat_decomp(k)

    ! solve tridiagonal system
    call tridiag_solve(a,b,c,r,x,nl)
    ! assign new lake temperature
    t_sublake(1:nl) = x


    ! PHASE CHANGE

    do k=1,nl
      w_ice = w_i_sublake(k)
      w_liq = w_w_sublake(k)
      ! maximum liquid water content, kg/m2, Niu 2006 (WRONG in CLM technical report)
      if( t_sublake(k) .lt. T0 ) then
        w_liq_max = dz(k) * rho_w * theta_sat(k) & 
        * ( Lf / (g*t_sublake(k)*psi_sat(k)) * (t_sublake(k)-T0) )**(1._wp/psi_exp(k))
      else
        w_liq_max = dz(k) * rho_w * theta_sat(k)
      endif

      ! freezing or melting occuring
      if( (t_sublake(k).gt.T0 .and. w_ice.gt.0._wp) .or. (t_sublake(k).lt.T0 .and. w_liq.gt.w_liq_max) ) then
        if( (t_sublake(k).gt.T0 .and. w_ice.gt.0._wp) ) then
          melt = .true.
        else
          melt = .false.
        endif

        H = -cap(k)*rdt*(T0 - t_sublake(k))
        ! update ice content
        w_melt = H*dt/Lf  ! kg/m2

        ! melting
        if( w_melt .gt. 0._wp .and. melt ) then
          w_i_sublake(k) = max(0._wp, w_ice-w_melt)
          ! determine energy not used during melt and adjust temperature if necessary
          H_star = H - Lf * (w_ice - w_i_sublake(k)) * rdt
          t_sublake(k) = T0 + dt*rcap(k) * H_star

        ! freezing
        else if( w_melt .lt. 0._wp .and. (.not. melt) ) then
          if( (w_liq+w_ice) .ge. w_liq_max ) then
            w_i_sublake(k) = min(w_liq+w_ice-w_liq_max, w_ice-w_melt) 
          else
            w_i_sublake(k) = 0._wp
          endif
          ! determine energy not released during freezing and adjust temperature if necessary
          H_star = H - Lf * (w_ice - w_i_sublake(k)) * rdt
          t_sublake(k) = T0 + dt*rcap(k) * H_star

        endif

        ! update liquid water content
        w_w_sublake(k) = w_liq+w_ice - w_i_sublake(k)

      endif

    enddo


    ! update theta
    do k=1,nl
      theta_w_sublake(k) = w_w_sublake(k) / (dz(k) * rho_w)
      theta_i_sublake(k) = w_i_sublake(k) / (dz(k) * rho_i)
    enddo

    if( check_energy ) then
      ! lake energy balance
      energy_cois_lake = -lambda_int_sublake(0)*rdz_neg(1)*(x(1)-t_sublake(0)) &
      + sum(heat_decomp*dz(1:nl)) &
      - sum(Lf*rdt * (w_i_old-w_i_sublake)) &
      - sum(cap*rdt * (t_sublake(1:nl)-t_sublake_old(1:nl)))

      if(abs(energy_cois_lake).gt.1.d-10 ) then
        print *,' '
        print *,'energy conservation lake',energy_cois_lake
        print *,'i,j',i,j
        print *,'t_sublake_old',t_sublake_old
        print *,'t_sublake_after_cond',x
        print *,'t_sublake_new',t_sublake
        print *,'w_i_old',w_i_old
        print *,'w_i_new',w_i_sublake
        print *,'flux_in',-lambda_int_sublake(0)*rdz_neg(1)*(t_sublake(1)-t_sublake(0))
        print *,'heat_soc',sum(heat_decomp*dz(1:nl))
        print *,'energy_internal',cap*rdt * (t_sublake(1:nl)-t_sublake_old(1:nl))
        print *,'phase change',Lf*rdt * (w_i_old-w_i_sublake)
        print *,'cap',cap
        print *,'lambda_int_sublake',lambda_int_sublake
        print *,' '
        !       if(abs(energy_cois_lake).gt.10.) stop
      endif
    endif


    ! check temperature range
    if(maxval(t_sublake) .gt. 350._wp .or. minval(t_sublake) .lt. 200._wp) then
      print *,''
      print *,'WARNING t_sublake out of range',t_sublake
      print *,'i,j',i,j
      k=1
      print *,'top lake layer'
      print *,'t_sublake, before, after',t_sublake_old(k),t_sublake(k)
      print *,'w_w, before, after',w_w_old(k),w_w_sublake(k)
      print *,'w_i, before, after',w_i_old(k),w_i_sublake(k)
      print *,'cap,lambda',cap, lambda_int_sublake
      print *,''
      !if(i.eq.54.and.j.eq.25) stop
    endif

    if(i_print .and. i.eq.54.and.j.eq.25) then
      print *,''
      print *,'WARNING t_sublake out of range',t_sublake
      print *,'i,j',i,j

      k=1
      print *,'top lake layer'
      print *,'t_sublake, before, after',t_sublake_old(k),t_sublake(k)
      print *,'w_w, before, after',w_w_old(k),w_w_sublake(k)
      print *,'w_i, before, after',w_i_old(k),w_i_sublake(k)
      print *,'cap,lambda',cap, lambda_int_sublake
      print *,''
    endif


    ! cumulate for lake carbon decomposition
    if (time_soy_lnd) then
      t_sublake_cum = 0._wp
      theta_w_sublake_cum = 0._wp
      theta_i_sublake_cum = 0._wp
    endif
    t_sublake_cum = t_sublake_cum + t_sublake(1:nl)
    theta_w_sublake_cum = theta_w_sublake_cum + theta_w_sublake
    theta_i_sublake_cum = theta_i_sublake_cum + theta_i_sublake


    return

  end subroutine sublake_temp

end module sublake_temp_mod

